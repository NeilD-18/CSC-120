# CSC-120 - Programming On Purpose 
# [Project 1 - What are the Odds?](https://github.com/NeilD-18/CSC-120/tree/8923af94f51d8ac073a4510a9a5daa54f196cfbe/Project%201%20-%20What%20are%20the%20Odds%3F%20ND)

Project creates and simulates poker hands from a deck of 52 cards. Displays a table of 10,0000-100,000 simulations, displaying the amount of each hand and percentage of each hand as well. Project displays good use of information hiding, modularity and various other good programming practices. Built using Python

# [Project 2 - How Does it Rank?](https://github.com/NeilD-18/CSC-120/tree/main/Project%202%20-%20How%20Does%20it%20Rank%3F%20ND)
Object-oriented programming project that compares two poker hands to determine the stronger hand. The project consists of three classes: Card Class, Deck Class, and Poker Hand Class. The Card Class encapsulates playing card properties, the Deck Class handles deck creation, shuffling and dealing, and the Poker Hand Class evaluates and compares hand strengths. The project follows good programming practices such as information hiding, private helper functions, modularity, and thorough unit testing. Built using Python.

# [Project 3 - Java Poker](https://github.com/NeilD-18/CSC-120/tree/main/Project%203%20-%20Java%20Poker%20ND)
Essentially Project 2 redone in Java. Various implementation changes in Deck Class to allow the dealing of a card from a Deck in O(1) time. 
Object-oriented programming project that compares two poker hands to determine the stronger hand. The project consists of three classes: Card Class, Deck Class, and Poker Hand Class. The Card Class encapsulates playing card properties, the Deck Class handles deck creation, shuffling and dealing, and the Poker Hand Class evaluates and compares hand strengths. The project follows good programming practices such as information hiding, private helper functions, modularity, and thorough unit testing. Built using Python.

# [Lab 1 - Re-presenting Python](https://github.com/NeilD-18/CSC-120/tree/main/Lab%201)
In this lab we built a game of dominoes where the game ended when one domino was twice the value of another. We created two modules, boneyard and domino and we implemented information hiding with the use of getter functions. Lab was mainly to get acclimated with Pycharm. 

# [Lab 2 - Tic-Tac-Test](https://github.com/NeilD-18/CSC-120/tree/main/Lab02%20Neil%20Daterao)
In this lab, we practiced writing test cases and testing functions within a game of Tic-Tac-Toe. We also practiced writing helper functions to automate our testing. Part of this lab involved practicing reading text data from files as input. 

# [Lab 3 - Vanquish the Evil](https://github.com/NeilD-18/CSC-120/tree/main/Lab03%20Neil%20Daterao)
In this lab, we refactored bad modules of code to avoid the use of global variables. Also practiced writing good docstrings for our functions. 

# [Lab 4 - Die with Class](https://github.com/NeilD-18/CSC-120/tree/main/Lab04%20Neil%20Daterao)
In this lab, we implimented objected oriented programming practices into a game of Die. We created a Die class to play this game of Die with 2 Dice objects. We also incorporated a concept of default parameters into our Die Constructor. 

# [Lab 5 - Covering Our Bases](https://github.com/NeilD-18/CSC-120/tree/main/Lab05%20Neil%20Daterao)
In this lab, we practiced making test cases and test suites, essentially implimented thorough unit testing into a game of Tic-Tac-Toe. While analyzing the starter code of this lab, we also identified private methods, instance variables, and how the tic-tac-toe board is represented in code. 

# [Lab 6 - It's Sort of Efficient](https://github.com/NeilD-18/CSC-120/tree/main/Lab06%20Neil%20Daterao)
In this lab, we analyzed two different sorting algorithms and collected the data of these two algorithms to determine the time complexity of each one. We also created graphs displaying the time complexity of each array given different inputs. Purpose of the lab was to practice our Big-O notation. For this lab, we weren't able to read source code as it was encrypted, thus we had to collect data of the number of list accesses and list size to determine running time. 

# [Lab 7 - Die with Class, Part II](https://github.com/NeilD-18/CSC-120/tree/main/Lab07%20Neil%20Daterao)
In this lab, we practiced writing classes in Java. This is essentially Lab 4 redone in Java. Instead of having default parameters like we did in Lab 4, we incorporated default constructors for our Die Class. We also cleanly documented our functions using Javadocs. 

# [Lab 8 - Hit the Deck!](https://github.com/NeilD-18/CSC-120/tree/main/Lab08%20Neil%20Daterao)
In this lab, we had more practice with information hiding. This lab showed us that we can have different implimentations of a method with the same exact behavior. This lab was a subset of our Project 3. We rewrote our deck class such that we could shuffle our deck of cards without actually changing the order of our deck. Lab was tested using various debugging methods. 


